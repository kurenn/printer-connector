# Printer Connector API Integration Guide

> **Audience:** Rails API developers working on the PrintDock backend  
> **Purpose:** Complete reference for integrating with the Go-based printer connector agent  
> **Last Updated:** December 31, 2025

---

## Table of Contents

- [Overview](#overview)
- [Architecture](#architecture)
- [Authentication](#authentication)
- [API Endpoints](#api-endpoints)
  - [1. Pairing/Registration](#1-pairingregistration)
  - [2. Heartbeat](#2-heartbeat)
  - [3. Commands Polling](#3-commands-polling)
  - [4. Command Completion](#4-command-completion)
  - [5. Snapshots Push](#5-snapshots-push)
- [Command Types](#command-types)
- [Error Handling](#error-handling)
- [Testing & Debugging](#testing--debugging)

---

## Overview

The **Printer Connector** is a lightweight Go agent that runs on a Raspberry Pi/Linux device inside the printer's local network. It bridges Moonraker (Klipper's API) with your Rails cloud application (PrintDock).

### Key Characteristics

- **Language:** Go 1.23+ (stdlib only, zero external dependencies)
- **Communication:** HTTPS outbound connections only (no open ports required)
- **Architecture:** Poll-based (connector initiates all requests to your API)
- **Concurrency:** Runs 3 concurrent loops (heartbeat, commands, snapshots)
- **Timeouts:** 5 second HTTP timeout, 2 second dial timeout

### Data Flow

```
┌─────────────────────┐
│  Rails API          │
│  (PrintDock)        │
│                     │
│  - Stores commands  │
│  - Receives updates │
└──────────▲──────────┘
           │
           │ HTTPS (outbound)
           │
┌──────────▼──────────┐         ┌─────────────────┐
│  Connector Agent    │◄────────┤  Moonraker      │
│  (Go Service)       │  HTTP   │  (Klipper API)  │
│                     │         │                 │
│  - Polls commands   │         │  - Controls     │
│  - Sends heartbeat  │         │    printer      │
│  - Pushes snapshots │         │  - File mgmt    │
└─────────────────────┘         └─────────────────┘
```

---

## Architecture

### Connector Lifecycle

1. **Startup:**
   - Reads config from JSON file (contains `pairing_token` on first run)
   - If `pairing_token` exists → calls `/api/v1/connectors/register`
   - Receives `connector_id` + `connector_secret` + `printer_ids`
   - Atomically rewrites config file (removes `pairing_token`, stores credentials)

2. **Running State:**
   - Launches 3 concurrent goroutines:
     - **Heartbeat Loop:** Every 10-15 seconds
     - **Commands Loop:** Every 3-5 seconds
     - **Snapshots Loop:** Every 30 seconds
   - Each loop has exponential backoff on errors (1s → 60s max)

3. **Shutdown:**
   - Graceful on SIGINT/SIGTERM
   - No state loss (reconnects on restart)

### Configuration Example

```json
{
  "cloud_url": "https://printdock.example.com",
  "connector_id": "conn_abc123",
  "connector_secret": "secret_xyz789",
  "poll_commands_seconds": 3,
  "push_snapshots_seconds": 30,
  "heartbeat_seconds": 10,
  "state_dir": "/var/lib/printer-connector",
  "moonraker": [
    {
      "printer_id": 42,
      "name": "Voron 2.4",
      "base_url": "http://127.0.0.1:7125",
      "ui_port": 80
    }
  ]
}
```

**Note:** `printer_id` is assigned by your Rails API during registration.

---

## Authentication

### Method: Bearer Token + Header

All authenticated requests include:

```http
Authorization: Bearer <connector_secret>
X-Connector-Id: <connector_id>
```

### Security Notes

- `connector_secret` is generated by Rails during registration
- Stored in config file with `0600` permissions (owner read/write only)
- Never logged or exposed
- Long-lived credential (no expiration in MVP)

### Example Authentication Headers

```bash
Authorization: Bearer sk_live_abc123xyz789
X-Connector-Id: conn_42
```

---

## API Endpoints

### 1. Pairing/Registration

**Purpose:** One-time pairing to exchange `pairing_token` for permanent credentials.

#### Request

```http
POST /api/v1/connectors/register
Content-Type: application/json
```

**Payload:**

```json
{
  "pairing_token": "PAIR_abc123xyz",
  "site_name": "Workshop",
  "device": {
    "hostname": "voron-pi",
    "arch": "arm64",
    "os": "linux",
    "version": "v0.1.0",
    "ip": "192.168.1.100",
    "ui_port": 80
  },
  "printers": [
    {
      "name": "Voron 2.4",
      "ui_port": 80
    }
  ]
}
```

**Field Descriptions:**

| Field | Type | Required | Description |
|-------|------|----------|-------------|
| `pairing_token` | string | **Yes** | One-time token from user's PrintDock account |
| `site_name` | string | No | Human-readable location name |
| `device.hostname` | string | No | Device hostname (informational) |
| `device.arch` | string | No | CPU architecture: `amd64`, `arm64`, `mips` |
| `device.os` | string | No | Operating system: `linux` |
| `device.version` | string | No | Connector version (e.g., `v0.1.0`) |
| `device.ip` | string | No | Local IP address |
| `device.ui_port` | int | No | Mainsail/Fluidd UI port |
| `printers` | array | No | Array of printers (usually 1 per connector) |
| `printers[].name` | string | No | Display name for printer |
| `printers[].ui_port` | int | No | UI port for this printer |

#### Response

```http
HTTP/1.1 200 OK
Content-Type: application/json
```

```json
{
  "connector": {
    "id": 42
  },
  "credentials": {
    "secret": "sk_live_abc123xyz789"
  },
  "printers": [
    {
      "id": 1,
      "name": "Voron 2.4"
    }
  ],
  "polling": {
    "commands_seconds": 3,
    "snapshots_seconds": 30
  }
}
```

**Field Descriptions:**

| Field | Type | Description |
|-------|------|-------------|
| `connector.id` | int or string | Unique connector ID (connector auto-converts) |
| `credentials.secret` | string | Permanent API secret for authentication |
| `printers[].id` | int | Printer ID assigned by Rails (used in commands) |
| `printers[].name` | string | Confirmed printer name |
| `polling.commands_seconds` | int | Recommended polling interval for commands |
| `polling.snapshots_seconds` | int | Recommended interval for snapshots |

**Important Notes:**

- `connector.id` may be returned as `int` or `"string"` - connector handles both
- `pairing_token` is single-use and should be invalidated after successful registration
- `printer_id` values are critical - commands reference these IDs

#### Error Responses

```json
// Invalid token
{
  "error": "Invalid or expired pairing token"
}
```

```json
// Token already used
{
  "error": "Pairing token already consumed"
}
```

---

### 2. Heartbeat

**Purpose:** Keep-alive signal to mark connector as online. Sent every 10-15 seconds.

#### Request

```http
POST /api/v1/connectors/:connector_id/heartbeat
Content-Type: application/json
Authorization: Bearer <connector_secret>
X-Connector-Id: <connector_id>
```

**Payload:**

```json
{
  "status": {
    "uptime_seconds": 3600,
    "version": "v0.1.0"
  },
  "printers": [
    {
      "printer_id": 1,
      "reachable": true
    }
  ]
}
```

**Field Descriptions:**

| Field | Type | Description |
|-------|------|-------------|
| `status.uptime_seconds` | int64 | Time in seconds since connector started |
| `status.version` | string | Connector software version |
| `printers[].printer_id` | int | Printer ID from registration |
| `printers[].reachable` | bool | `true` if Moonraker is responding |

**Reachability Check:**

Connector pings Moonraker before each heartbeat:
```
GET http://127.0.0.1:7125/printer/objects/query
```
If success → `reachable: true`, otherwise `false`.

#### Response

```http
HTTP/1.1 200 OK
Content-Type: application/json
```

```json
{
  "status": "ok"
}
```

Or simply `204 No Content`.

#### Error Responses

```http
// Invalid credentials
HTTP/1.1 401 Unauthorized
{
  "error": "Unauthorized"
}
```

```http
// Connector not found
HTTP/1.1 404 Not Found
{
  "error": "Connector not found"
}
```

#### Rails Implementation Considerations

- Update `connectors.last_heartbeat_at = NOW()`
- Update `connectors.status = 'online'`
- Store `uptime_seconds` for monitoring
- Update each printer's `reachable` status
- Consider marking connector offline if no heartbeat for 60+ seconds

---

### 3. Commands Polling

**Purpose:** Fetch pending commands for execution. Polled every 3-5 seconds.

#### Request

```http
GET /api/v1/connectors/:connector_id/commands?limit=20
Authorization: Bearer <connector_secret>
X-Connector-Id: <connector_id>
```

**Query Parameters:**

| Parameter | Type | Default | Description |
|-----------|------|---------|-------------|
| `limit` | int | 20 | Max commands to return per request |

#### Response

```http
HTTP/1.1 200 OK
Content-Type: application/json
```

**Response MUST be a JSON array:**

```json
[
  {
    "id": "cmd_abc123",
    "printer_id": 1,
    "action": "start_print",
    "params": {
      "filename": "test.gcode"
    }
  },
  {
    "id": "cmd_xyz789",
    "printer_id": 1,
    "action": "upload_file",
    "params": {
      "filename": "benchy.gcode",
      "content": "RzI4IEcxIFgxMCBZMTAuLi4="
    }
  }
]
```

**Empty response:**

```json
[]
```

**Field Descriptions:**

| Field | Type | Description |
|-------|------|-------------|
| `id` | string | Unique command ID (used in completion) |
| `printer_id` | int | Target printer (from registration) |
| `action` | string | Command type (see [Command Types](#command-types)) |
| `params` | object | Action-specific parameters |

#### Important Notes

- **MUST return JSON array**, not object wrapper
- Commands should be filtered by:
  - `connector_id` matches requesting connector
  - `status = 'pending'`
  - Order by `created_at ASC` (FIFO)
- After returning commands, Rails should mark them as `status = 'running'`
- Commands are executed **sequentially** by connector

#### Error Responses

```http
HTTP/1.1 401 Unauthorized
{
  "error": "Unauthorized"
}
```

---

### 4. Command Completion

**Purpose:** Report command execution result. Called after every command execution.

#### Request

```http
POST /api/v1/commands/:command_id/complete
Content-Type: application/json
Authorization: Bearer <connector_secret>
X-Connector-Id: <connector_id>
```

**Success Payload:**

```json
{
  "status": "succeeded",
  "result": {
    "action": "start_print",
    "filename": "test.gcode",
    "post_snapshot": "captured"
  }
}
```

**Failure Payload:**

```json
{
  "status": "failed",
  "error_message": "Moonraker returned status 404: File not found",
  "result": {
    "action": "start_print",
    "filename": "missing.gcode"
  }
}
```

**Field Descriptions:**

| Field | Type | Required | Description |
|-------|------|----------|-------------|
| `status` | string | **Yes** | Either `"succeeded"` or `"failed"` |
| `result` | object | No | Action-specific result data |
| `error_message` | string | Required if failed | Human-readable error description |

#### Response

```http
HTTP/1.1 200 OK
Content-Type: application/json
```

```json
{
  "status": "ok"
}
```

Or `204 No Content`.

#### Command-Specific Results

**start_print:**
```json
{
  "status": "succeeded",
  "result": {
    "action": "start_print",
    "filename": "benchy.gcode",
    "post_snapshot": "captured"
  }
}
```

**upload_file:**
```json
{
  "status": "succeeded",
  "result": {
    "action": "upload_file",
    "filename": "test.gcode",
    "size": 12345,
    "post_snapshot": "captured"
  }
}
```

**sync_files:**
```json
{
  "status": "succeeded",
  "result": {
    "action": "sync_files",
    "count": 42,
    "files": [
      {
        "path": "benchy.gcode",
        "size": 12345,
        "modified": 1640995200.0
      }
    ],
    "post_snapshot": "captured"
  }
}
```

**delete_file:**
```json
{
  "status": "succeeded",
  "result": {
    "action": "delete_file",
    "filename": "old.gcode",
    "post_snapshot": "captured"
  }
}
```

**pause/resume/cancel:**
```json
{
  "status": "succeeded",
  "result": {
    "action": "pause",
    "post_snapshot": "captured"
  }
}
```

#### Rails Implementation Considerations

- Update command record: `status = params[:status]`
- Store `result` JSON for debugging
- Store `error_message` if failed
- Update `completed_at = NOW()`
- For `sync_files`: Extract and store file list in database
- Trigger any webhooks/notifications
- Mark command as complete to prevent re-execution

---

### 5. Snapshots Push

**Purpose:** Push printer status snapshots. Sent every 30 seconds.

#### Request

```http
POST /api/v1/snapshots/batch
Content-Type: application/json
Authorization: Bearer <connector_secret>
X-Connector-Id: <connector_id>
```

**Payload:**

```json
{
  "snapshots": [
    {
      "printer_id": 1,
      "captured_at": "2025-12-31T00:00:00Z",
      "payload": {
        "status": {
          "print_stats": {
            "state": "printing",
            "filename": "benchy.gcode",
            "total_duration": 3600.5,
            "print_duration": 3500.2,
            "filament_used": 15.432
          },
          "virtual_sdcard": {
            "progress": 0.75,
            "file_position": 750000,
            "file_size": 1000000
          },
          "extruder": {
            "temperature": 210.5,
            "target": 210.0,
            "power": 0.15
          },
          "heater_bed": {
            "temperature": 60.2,
            "target": 60.0,
            "power": 0.05
          },
          "toolhead": {
            "position": [125.5, 130.2, 45.8, 1500.3],
            "max_velocity": 300.0,
            "max_accel": 3000.0
          },
          "pause_resume": {
            "is_paused": false
          }
        },
        "eventtime": 1640995200.123456,
        "result": {
          "status": "object data here"
        }
      }
    }
  ]
}
```

**Field Descriptions:**

| Field | Type | Description |
|-------|------|-------------|
| `snapshots` | array | Array of snapshot objects |
| `printer_id` | int | Printer ID from registration |
| `captured_at` | string | ISO 8601 timestamp (RFC3339) |
| `payload` | object | Raw Moonraker response from `/printer/objects/query` |

**Payload Structure:**

The `payload` contains the raw response from Moonraker's `/printer/objects/query` endpoint. Key fields:

- `status.print_stats.state`: `"standby"`, `"printing"`, `"paused"`, `"complete"`, `"cancelled"`, `"error"`
- `status.print_stats.filename`: Current/last printed file
- `status.virtual_sdcard.progress`: Print progress (0.0 to 1.0)
- `status.extruder.temperature`: Current nozzle temp
- `status.heater_bed.temperature`: Current bed temp

#### Response

```http
HTTP/1.1 200 OK
Content-Type: application/json
```

```json
{
  "inserted": 1
}
```

**Field Descriptions:**

| Field | Type | Description |
|-------|------|-------------|
| `inserted` | int | Number of snapshots successfully stored |

#### Rails Implementation Considerations

- Store snapshots in time-series fashion
- Index by `printer_id` and `captured_at` for queries
- Consider data retention policy (e.g., keep 30 days)
- Extract key metrics for dashboard display:
  - Current print status
  - Print progress percentage
  - Temperatures
  - ETA calculation
- Use for real-time updates via WebSockets/ActionCable

---

## Command Types

### Overview

The connector supports the following command actions:

| Action | Purpose | Params |
|--------|---------|--------|
| `pause` | Pause current print | None |
| `resume` | Resume paused print | None |
| `cancel` | Cancel current print | None |
| `start_print` | Start printing a file | `filename` |
| `upload_file` | Upload G-code file | `filename`, `content` (base64) |
| `delete_file` | Delete G-code file | `filename` |
| `sync_files` | Fetch file list | None |

---

### 1. pause

**Purpose:** Pause the current print job.

**Command:**
```json
{
  "id": "cmd_123",
  "printer_id": 1,
  "action": "pause",
  "params": {}
}
```

**Moonraker Call:**
```http
POST http://127.0.0.1:7125/printer/print/pause
```

**Completion:**
```json
{
  "status": "succeeded",
  "result": {
    "action": "pause",
    "post_snapshot": "captured"
  }
}
```

---

### 2. resume

**Purpose:** Resume a paused print job.

**Command:**
```json
{
  "id": "cmd_124",
  "printer_id": 1,
  "action": "resume",
  "params": {}
}
```

**Moonraker Call:**
```http
POST http://127.0.0.1:7125/printer/print/resume
```

**Completion:**
```json
{
  "status": "succeeded",
  "result": {
    "action": "resume",
    "post_snapshot": "captured"
  }
}
```

---

### 3. cancel

**Purpose:** Cancel the current/paused print job.

**Command:**
```json
{
  "id": "cmd_125",
  "printer_id": 1,
  "action": "cancel",
  "params": {}
}
```

**Moonraker Call:**
```http
POST http://127.0.0.1:7125/printer/print/cancel
```

**Completion:**
```json
{
  "status": "succeeded",
  "result": {
    "action": "cancel",
    "post_snapshot": "captured"
  }
}
```

---

### 4. start_print

**Purpose:** Start printing a G-code file that already exists on the printer.

**Command:**
```json
{
  "id": "cmd_126",
  "printer_id": 1,
  "action": "start_print",
  "params": {
    "filename": "benchy.gcode"
  }
}
```

**Required Params:**

| Param | Type | Description |
|-------|------|-------------|
| `filename` | string | G-code filename (in Moonraker's gcodes directory) |

**Moonraker Call:**
```http
POST http://127.0.0.1:7125/printer/print/start?filename=benchy.gcode
```

**Completion (Success):**
```json
{
  "status": "succeeded",
  "result": {
    "action": "start_print",
    "filename": "benchy.gcode",
    "post_snapshot": "captured"
  }
}
```

**Completion (Failure):**
```json
{
  "status": "failed",
  "error_message": "moonraker http 404: File not found",
  "result": {
    "action": "start_print",
    "filename": "missing.gcode"
  }
}
```

---

### 5. upload_file

**Purpose:** Upload a new G-code file to the printer.

**Command:**
```json
{
  "id": "cmd_127",
  "printer_id": 1,
  "action": "upload_file",
  "params": {
    "filename": "new_print.gcode",
    "content": "RzI4IEcxIFgxMCBZMTAgWjAuMwpHMSBYMjAgWTIwCkcy...(base64)..."
  }
}
```

**Required Params:**

| Param | Type | Description |
|-------|------|-------------|
| `filename` | string | Desired filename (will be saved in gcodes directory) |
| `content` | string | Base64-encoded G-code file content |

**Encoding Example (Rails):**
```ruby
# In Rails controller
file_content = params[:file].read
base64_content = Base64.strict_encode64(file_content)

Command.create!(
  connector_id: connector.id,
  printer_id: printer.id,
  action: 'upload_file',
  params: {
    filename: params[:file].original_filename,
    content: base64_content
  }
)
```

**Moonraker Call:**
```http
POST http://127.0.0.1:7125/server/files/upload
Content-Type: multipart/form-data; boundary=----WebKitFormBoundary...

------WebKitFormBoundary...
Content-Disposition: form-data; name="file"; filename="new_print.gcode"
Content-Type: application/octet-stream

G28 G1 X10 Y10 Z0.3
G1 X20 Y20
...
------WebKitFormBoundary...
Content-Disposition: form-data; name="root"

gcodes
------WebKitFormBoundary...--
```

**Completion (Success):**
```json
{
  "status": "succeeded",
  "result": {
    "action": "upload_file",
    "filename": "new_print.gcode",
    "size": 12345,
    "post_snapshot": "captured"
  }
}
```

**Completion (Failure):**
```json
{
  "status": "failed",
  "error_message": "failed to decode base64 content: illegal base64 data at input byte 4",
  "result": {
    "action": "upload_file",
    "filename": "new_print.gcode"
  }
}
```

---

### 6. delete_file

**Purpose:** Delete a G-code file from the printer.

**Command:**
```json
{
  "id": "cmd_128",
  "printer_id": 1,
  "action": "delete_file",
  "params": {
    "filename": "old_print.gcode"
  }
}
```

**Required Params:**

| Param | Type | Description |
|-------|------|-------------|
| `filename` | string | G-code filename to delete (in gcodes directory) |

**Moonraker Call:**
```http
DELETE http://127.0.0.1:7125/server/files/gcodes/old_print.gcode
```

**Completion (Success):**
```json
{
  "status": "succeeded",
  "result": {
    "action": "delete_file",
    "filename": "old_print.gcode",
    "post_snapshot": "captured"
  }
}
```

**Completion (Failure):**
```json
{
  "status": "failed",
  "error_message": "moonraker http 404: File not found",
  "result": {
    "action": "delete_file",
    "filename": "nonexistent.gcode"
  }
}
```

---

### 7. sync_files

**Purpose:** Fetch the complete list of G-code files from the printer.

**Command:**
```json
{
  "id": "cmd_129",
  "printer_id": 1,
  "action": "sync_files",
  "params": {}
}
```

**Moonraker Call:**
```http
GET http://127.0.0.1:7125/server/files/list?root=gcodes
```

**Moonraker Response Example:**
```json
{
  "result": [
    {
      "path": "benchy.gcode",
      "modified": 1640995200.123,
      "size": 1234567,
      "permissions": "rw"
    },
    {
      "path": "calibration_cube.gcode",
      "modified": 1640995100.456,
      "size": 987654,
      "permissions": "rw"
    }
  ]
}
```

**Completion (Success):**
```json
{
  "status": "succeeded",
  "result": {
    "action": "sync_files",
    "count": 2,
    "files": [
      {
        "path": "benchy.gcode",
        "modified": 1640995200.123,
        "size": 1234567,
        "permissions": "rw"
      },
      {
        "path": "calibration_cube.gcode",
        "modified": 1640995100.456,
        "size": 987654,
        "permissions": "rw"
      }
    ],
    "post_snapshot": "captured"
  }
}
```

**Rails Usage:**

After receiving `sync_files` completion, extract the files array and update your database:

```ruby
# In CommandsController or background job
def handle_sync_files_completion(command)
  files = command.result['files']
  printer = command.printer
  
  # Clear existing files
  printer.gcode_files.destroy_all
  
  # Insert new files
  files.each do |file_data|
    printer.gcode_files.create!(
      filename: file_data['path'],
      size: file_data['size'],
      modified_at: Time.at(file_data['modified']),
      permissions: file_data['permissions']
    )
  end
  
  printer.update!(last_synced_at: Time.current)
end
```

**Completion (Failure):**
```json
{
  "status": "failed",
  "error_message": "failed to list files from moonraker: moonraker http 503: Service unavailable",
  "result": {
    "action": "sync_files"
  }
}
```

---

## Error Handling

### Connector Behavior on Errors

#### Network Errors
- **Timeout:** Logs warning, continues with exponential backoff
- **Connection refused:** Logs warning, retries with backoff
- **DNS failure:** Logs error, retries with backoff

#### HTTP Errors
- **401 Unauthorized:** Logs error, continues polling (credentials may be invalid)
- **404 Not Found:** Logs error, continues (endpoint may be wrong)
- **5xx Server Error:** Logs warning, retries with backoff

#### Command Execution Errors
- **Moonraker unreachable:** Command marked as failed, completion sent
- **Moonraker returns error:** Command marked as failed, completion sent with error message
- **Invalid params:** Command marked as failed immediately

### Expected Rails Behavior

#### Invalid Authentication
```http
HTTP/1.1 401 Unauthorized
Content-Type: application/json

{
  "error": "Invalid or missing credentials"
}
```

Connector will:
- Log error
- Continue polling (may be transient)
- Admin should check logs and verify credentials

#### Connector Not Found
```http
HTTP/1.1 404 Not Found
Content-Type: application/json

{
  "error": "Connector not found"
}
```

Connector will:
- Log error
- Continue polling
- May need re-pairing

#### Command Not Found (during completion)
```http
HTTP/1.1 404 Not Found
Content-Type: application/json

{
  "error": "Command not found"
}
```

Connector will:
- Log warning
- Continue with next command
- No retry (command may have been manually deleted)

### Idempotency

- **Heartbeat:** Idempotent (can be called multiple times)
- **Command Completion:** Idempotent (should accept duplicate completions gracefully)
- **Registration:** **NOT** idempotent (pairing_token is single-use)

---

## Testing & Debugging

### Testing New Commands

1. **Create a pending command in Rails:**
   ```ruby
   Command.create!(
     connector_id: 1,
     printer_id: 1,
     action: 'sync_files',
     status: 'pending',
     params: {}
   )
   ```

2. **Watch connector logs:**
   ```bash
   journalctl -u printer-connector -f
   ```

3. **Verify command execution:**
   - Connector polls within 3-5 seconds
   - Logs show: `"executing command" command_id=...`
   - Logs show: `"command succeeded"` or `"command failed"`
   - Completion callback is made
   - Rails updates command status to `succeeded` or `failed`

### Checking Command Status

```ruby
# In Rails console
Command.where(status: 'running').count
# Should be 0 if connector is working properly

Command.where(status: 'pending').count
# Shows commands waiting to be picked up

Command.last
# Check most recent command status and result
```

### Common Issues

#### Commands Stuck in "running"
**Symptom:** Commands never complete, status stays `running`

**Cause:** Connector not calling completion endpoint

**Solution:** Check connector logs for HTTP errors to `/api/v1/commands/:id/complete`

#### Commands Never Picked Up
**Symptom:** Commands stay `pending` forever

**Cause:** 
- Connector not polling
- Connector offline
- Wrong `connector_id` in command

**Solution:** 
- Check connector heartbeat timestamp
- Verify `connector_id` matches
- Check connector logs

#### Commands Execute But Fail
**Symptom:** Commands marked as `failed` with error messages

**Cause:** Moonraker issues or invalid params

**Solution:**
- Check `error_message` in command result
- Verify Moonraker is running
- Verify params are correct (especially filenames)

### Debug Mode

Run connector in debug mode:
```bash
./printer-connector --config config.json --log-level debug
```

This shows:
- All HTTP requests/responses
- Detailed error messages
- Timing information
- Command parameter parsing

### One-Shot Mode (Testing)

Run connector once without looping:
```bash
./printer-connector --config config.json --once
```

Useful for:
- Testing pairing
- Verifying connectivity
- Debugging command execution

---

## Rails Implementation Checklist

### Registration Endpoint
- [ ] Validate pairing token
- [ ] Generate connector_id and connector_secret
- [ ] Create connector record
- [ ] Assign printer_ids (one per printer in request)
- [ ] Invalidate pairing token after use
- [ ] Return proper response structure

### Heartbeat Endpoint
- [ ] Authenticate request
- [ ] Update `last_heartbeat_at` timestamp
- [ ] Update connector status to 'online'
- [ ] Store uptime and version info
- [ ] Update printer reachability status
- [ ] Return 200 OK or 204 No Content

### Commands Polling Endpoint
- [ ] Authenticate request
- [ ] Filter commands by connector_id
- [ ] Only return `status: 'pending'` commands
- [ ] Order by created_at ASC (FIFO)
- [ ] Limit results (default 20)
- [ ] Mark returned commands as `status: 'running'`
- [ ] **Return JSON array** (not wrapped object)

### Command Completion Endpoint
- [ ] Authenticate request
- [ ] Find command by ID
- [ ] Update status to 'succeeded' or 'failed'
- [ ] Store result JSON
- [ ] Store error_message if failed
- [ ] Update completed_at timestamp
- [ ] Handle sync_files result (extract files array)
- [ ] Trigger webhooks/notifications if needed
- [ ] Return 200 OK or 204 No Content

### Snapshots Endpoint
- [ ] Authenticate request
- [ ] Parse snapshots array
- [ ] Validate printer_id belongs to connector
- [ ] Store snapshots in time-series table
- [ ] Extract key metrics for dashboard
- [ ] Update printer's current status
- [ ] Return inserted count

### Security
- [ ] Validate all authentication headers
- [ ] Rate limit endpoints appropriately
- [ ] Log authentication failures
- [ ] Sanitize error messages (don't leak sensitive info)
- [ ] Use HTTPS in production

---

## Example Rails Controller Skeleton

```ruby
class Api::V1::ConnectorsController < ApiController
  before_action :authenticate_connector!, except: [:register]
  
  def register
    token = PairingToken.find_by(token: params[:pairing_token])
    return render_error('Invalid pairing token', 401) unless token&.valid?
    
    connector = Connector.create!(
      site_name: params[:site_name],
      secret: SecureRandom.hex(32),
      status: 'online',
      device_info: params[:device]
    )
    
    printers = params[:printers]&.map do |p|
      Printer.create!(
        connector: connector,
        name: p[:name],
        ui_port: p[:ui_port]
      )
    end
    
    token.consume!
    
    render json: {
      connector: { id: connector.id },
      credentials: { secret: connector.secret },
      printers: printers.map { |p| { id: p.id, name: p.name } },
      polling: {
        commands_seconds: 3,
        snapshots_seconds: 30
      }
    }
  end
  
  def heartbeat
    @connector.update!(
      last_heartbeat_at: Time.current,
      status: 'online',
      uptime_seconds: params[:status][:uptime_seconds],
      version: params[:status][:version]
    )
    
    params[:printers]&.each do |p|
      printer = @connector.printers.find_by(id: p[:printer_id])
      printer&.update!(reachable: p[:reachable])
    end
    
    head :no_content
  end
  
  def commands
    commands = @connector.commands
      .where(status: 'pending')
      .order(created_at: :asc)
      .limit(params[:limit] || 20)
    
    commands.update_all(status: 'running', started_at: Time.current)
    
    render json: commands.as_json(only: [:id, :printer_id, :action, :params])
  end
  
  private
  
  def authenticate_connector!
    secret = request.headers['Authorization']&.remove('Bearer ')
    connector_id = request.headers['X-Connector-Id']
    
    @connector = Connector.find_by(id: connector_id, secret: secret)
    return render_error('Unauthorized', 401) unless @connector
  end
  
  def render_error(message, status)
    render json: { error: message }, status: status
  end
end

class Api::V1::CommandsController < ApiController
  before_action :authenticate_connector!
  
  def complete
    command = Command.find(params[:id])
    
    command.update!(
      status: params[:status],
      result: params[:result],
      error_message: params[:error_message],
      completed_at: Time.current
    )
    
    # Handle sync_files special case
    if command.action == 'sync_files' && params[:status] == 'succeeded'
      SyncFilesJob.perform_later(command.id)
    end
    
    head :no_content
  end
end

class Api::V1::SnapshotsController < ApiController
  before_action :authenticate_connector!
  
  def batch
    inserted = 0
    
    params[:snapshots].each do |snapshot|
      printer = @connector.printers.find_by(id: snapshot[:printer_id])
      next unless printer
      
      Snapshot.create!(
        printer: printer,
        captured_at: snapshot[:captured_at],
        payload: snapshot[:payload]
      )
      
      inserted += 1
    end
    
    render json: { inserted: inserted }
  end
end
```

---

## Contact & Support

For questions about connector integration:
- **GitHub Issues:** https://github.com/kurenn/printer-connector/issues
- **GitHub Discussions:** https://github.com/kurenn/printer-connector/discussions

---

**Document Version:** 1.0.0  
**Connector Version:** v0.1.0  
**Last Updated:** December 31, 2025
